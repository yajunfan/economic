<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="./css/reset.css">
    <link rel="stylesheet" href="./css/index.css">
</head>
<body>
        
    <div>
        <h2>node学习</h2>
        <ul class="list">
            <li>一.在事件中，var events = require('events');
                var EventEmitter= new events.<span class="tdu">EventEmitter</span>();
                <span class="red fwb">E</span>ventEmitter  这个E要大写，否则找不到该元素</li>
            
            <li>二. 关于node的事件，很像电路图。最关键的一个emit是主要开关，其余的emit是各自的小开关，而on就是每个线路都接好了，等到什么时候住开关按下，走到哪个on监听的开关上，哪个开关
                就打开执行，打开电路。
                有个重要的一点，是我的主开关要放在最后面，相当于这个总开关要放在我的眼跟前的感觉;
            </li>
            <li><h4>三. 关于fs的理解</h4>
                 var <span class="red">readsteam</span> = fs.<span class="red">createReadStream</span>('input.txt')[这是源文件];<br>
                 var <span class="green">writeSream</span> = fs.<span class="green">createWriteStream</span>('output.txt')[这是要写入的那个文件];<br>
                 readsteam.pipe(writeSream); 就将input.txt中的内容写入了output.txt文件中，会完全覆盖output中的内容<br>
                后续理解了追加在填
            </li>
            <li><h4>四. 关于模块</h4>
                对我而言，相当于是有一个公共的文件，其中放入很多我自己封装的方法，比如 <b>util.js</b>
                <textarea  rows="10" class="" style="width: 100%;">
                那么在我的util.js中，我会这么写
                    exports.Utils={
                       aa:function(){相关逻辑},
                       bb:function(){相关逻辑},
                       cc:function(){相关逻辑},
                       ...
                    };
                在别的js页面，比如main.js页面，直接引入utils
                   var Utils = require('./utils');(这个就是这个utils的相对位置，根据自己的文件进行跳转)
                   在这个页面能调用utils的方法
                   Utils.aa();
                   Utils.bb();
                   ...
                   有时候我们只是想把一个对象封装到模块中，格式如下：
                    module.exports = function() {
                        ...
                    }
                    那我们在utils的文件中这么写
                    function Utils() {
                        var name; 
                        this.aa = function(thyName) { 
                            name = thyName; 
                        }; 
                        this.bb = function() { 
                            console.log('Hello ' + name);
                        }; 
                    }; 
                    或者导出的是一个对象
                    var Utils = function(){
                        var obj={
                            aa:function(){console.log('aaaa')  },
                            bb:function () {console.log('bbdd')  },
                            cc:function () {console.log('dsdfsf')  }
                        }
                        return obj;
                    };
                    module.exports = Utils;
                    在main.js中
                    var Utils = require('./Utils');
                    Utils = new Utils(); 
                    Utils.aa('BYVoid');
                    Utils.bb();
                </textarea>
                这两者的区别呢：<br>
                <b>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</b>
           </li>
        </ul>
        <div class="footer tlc">访问网址：https://yajunfan.github.io/economic/</div>
    </div>
</body>
</html>